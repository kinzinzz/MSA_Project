## **Elasticsearch**

- Elasticsearch is written in Java and thus uses the Java Virtual Machine(JVM)
- 데이터 저장소가 아니라 MySQL같은 DB를 대체할 수 없다.
- Elasticsearch는 검색을 위해 단독으로 사용되기도 하며, ELK(Elasticsearch + Logstash + Kibana)스택을 사용되기도 한다.



## **Elasticsearch를 사용하는 이유는?**

- **Elasticsearch는 빠르다.**

  Elasticsearch는 Lucene을 기반으로 구축되기 때문에, 전체 텍스트 검색에 뛰어납니다. Elasticsearch는 또한 거의 실시간 검색 플랫폼이다. 이것은 문서가 색인될 때부터 검색 가능해질 때까지의 대기 시간이 아주 짧다는 뜻이다. 이 대기 시간은 보통 1초다.

- **Elasticsearch는 본질상 분산적이다.**

  Elascticsearch에 저장된 문서는 샤드라고 하느 여러 다른 컨테이너에 걸쳐 분산되며, 이 샤는 복제되어 하드웨서 장애 시에 중복되는 데이터 사본을 제공합니다. Elasticsearch의 분산적인 특징은 수백 개의 서버까지 확장할 수 있다.

- **Elastic Stack은 데이터 수집, 시각화, 보고를 간소화 한다.**

  Beats와 Logstash의 통합은 Elasticsearch로 색인하기 전에 데이터를 훨씬 더 쉽게 처리할 수 있게 해준다. Kibana는 Elasticsearch 데이터의 실시간 시각화를 제공하며, UI를 통해 Application 성능 모니터링(APM), 로그, 인프라 메트릭 데이터에 신속하게 접근할 수 있다. 



## **ELK**

- **ELK**는 분석 및 저장 기능을 담당하는 Elasticsearch, 수집 기능을 하는 Logstatsh, 이를 시각화하는 도구인 Kibana를 의미
- **Logstatsh**: 다양한 소스(DB, csv파일 등)의 로그 또는 트랜잭션 데이터를 수집, 집계, 파싱하여 Elasticsearch로 전달
- **Elasticsearch**: Logstatsh로 부터 받은 데이터를 검색 및 집계를 하여 필요한 관심 있는 정보를 획득
- **Kibana**: Elasticsearch의 빠른 검색을 통해 데이터를 시각화 및 모니터링



## **Elasticsearch와 DB(RDBMS)의 비교**

|  RDBMS   | Elasticsearch |
| :------: | :-----------: |
|  schema  |    mapping    |
| database |     index     |
|  table   |     type      |
|   row    |   document    |
|  column  |     field     |



## **Elasticsearch를 REST API를 사용하여 RDBMS간 관계**

| Elasticsearch | RDBMS  | CRUD   |
| ------------- | ------ | ------ |
| GET           | SELECT | READ   |
| PUT           | UPDATE | UPDATE |
| POST          | INSERT | CREATE |
| DELETE        | DELETE | DELETE |



## **Elasticsearch 핵심 개념**

- **cluster(클러스터)**

  클러스터느 하나 이상의 노드(서버)가 모인 것이며, 이를 통해 전체 데이터를  저장하고 모든 노드를 보관하는 통합 색인화 및 검색 기능을 제공한다. 클러스터는 고유한 이름으로 식별되는데, 기본 이름은 "elasticsearch"이다. 어떤 노드가 어느 클러스에 포함되기 위해서는 이름에 의해 클러스터의 구성원이 되도록 설정되기 때문에 이 이름이 매우 중요하다. 노드가 잘못된 클러스터에 포함될 위험이 있으므로 동일한 클러스터 이름을 서로 다른환경에서 재사용하면 안된다. 예를 들어 개발, 스테이징, 프로덕션 클러스터에 logging-dev, logging-stage, logging-prod라는 이름을 사용해야한다. 클러스터에 하나의 노드만 있는 것은 유효하며 또한 각자 고유한 클러스터 이름을 가진 독립적인 클러스터를 여러개 둘 수도 있다

- **node(노드)**

  노드는 클러스터에 포함된 단일 서버로서 데이터를 저장하고 클러스터의 색인화 및 검색 기능에 참여한다. 노드는 클러스터처럼 이름으로 식별되는데, 기본 이름은 시작 시 노드에 지정되는 임의 UUID(Universally Unique Identifier)이다. 기본이름 대신 특정 이름으로 정의 가능하며 네트워크 어떤 서버가 Elasticsearch 클러스터의 어떤 노드에 해당하는지 식별해야 하기 때문에 이름은 관리의 목적에서 중요하다. 노드는 클러스터 이름을 통해 어떤 클러스터의 일부로 구성될 수 있다. 기본적으로 각 노드는 'elasticsearch'라는 이름의 클러스터에 포함되도록 설정된다. 즉 네트워크에서 다수의 노드를 시작할 경우(각각을 검색할 수 있다고 가정하면) 이노드가 모두 자동으로 'elasticsearch'라는 단일클러스터를 형성하고 이 클러스터의 일부가 된다.

- **index(인덱스)**

  색인은 다소 비슷한 특성을 가진 문서의 모음읻다. 이를테면 고객 데이터에 대한 색인, 제품 카탈로그에 대한 색인, 주문 데이터에 대한 색인을 각각 둘 수 있다. 색인은 이름(모두 소문자)으로 식별되며, 이 이름은 색인에 포함된 문서에 대한 색인화, 검색, 업데이트, 삭제 작업에서 해당 색인을 가르키는데  쓰인다. 단일 클러스터에서 원하는 개수의 색인을 정의할 수 있다.

- **type(타입)**

  하나의 색인에서 하나 이상의 유형을 정의할 수 있다. 유형이란 색인을 논리적으로 분류/구분한 것이며 그 의미 체계는 전적으로 사용자가 결정한다. 일반적으로 여러 공통된 필드를 갖는 문서에 대해 유형이 정의 된다. 예를 들어 블로그 플랫폼을 운영하고 있는데 모든 데이터를 하나의 색인에 저장한다고 가정하면 이 색인에서 사용자 데이터, 블로그 데이터, 댓글 데이터에 대한 유형을 각각 정의할 수 있다.

- **document(도큐먼트)**

  도큐먼트는 색인화 할 수 있는 기본 정보 단위이다. 예를 들어 어떤 단일 고객, 단일 제품, 단일 주문에 대한 도큐먼트다 각각 존재할 수 있다. 이 문서는 JSON형식인데, 이는 널리 사용되는 인터넷 데이터 교환 형식이다.

- **shard(샤드)**

  색인은 방대한 양의 데이터를 저장할 수 있는데, 이 데이터가 단일 노드의 하드웨어 한도를 초과할 수 있다. 예를 들어 10억개의 문서로 구성된 하나의 색인에 1TB의 디스크 공간이 필요할 경우, 단일 노드의 디스크에서 수용하지 못하거나 단일 노드에서 검색 요청 처리 시 속도가 너무 느려질 수 있다. Elastisearch는 이러한 문제를 해결하고자 색인을 이른바 샤드(shard)라는 조각으로 분할하느 기능을 제공한다. 색인을 생성할 때 원하는 샤드 수를 간단히 정의할 수 있다. 각 샤드는 그 자체가 온전한 기능을 가진 독립적인 "색인"이며, 클러스터의 어떤 노드에서도 호스팅할 수있다. 샤딩은 2가지 중요한 이유가 있다. 첫째, 콘텐츠 볼륨의 수평 분할/확장이 가능해진다. 둘째, 작업(여러 노드에 위치한 경우라도)여러 샤드에 분산 배치하고 병렬화 함으로써 성능/처리량을 늘릴 수 있다. 언제든 오류가 일어날 가능성이 있는 네트워크/클라우드 환경에서는 어떤 이유에서든 샤드/노드가 오프라인 상태가 되거나 사라지게 될 경우에 대비하여 Fail-Over 매커니즘을 마련하는 것이 매우 유익하다. 이러한 취지에서 Elasticsearch에서는 색인의 샤드에 대해 하나 이상의 복사본을 생성할 수 있는데, 이를 리플리카 샤드(replica shard), 줄여서 리플리카라고 한다.

- **replica(리플리카)**

  리플리카를 만드는 복제는 2가지 중요한 이유가 있다. 첫째,  샤드/노드 오류가 발생하더라도 고가용성을 제공한다. 따라서 리플리카 샤드는 그 원본인 기본 샤드와 동일한 노드에 배정되지 않는다. 둘째, 모든 리플리카에서 병렬 방식으로 검색을 실행할 수 있으므로 검색 볼륨/처리량을 확장할 수 있다. 요약하자면 각 색인은 여러개의 샤드로 분할할 수 있다. 또한 하나의 색은 복제하지 않거나(리플리카 없는 경우)1회 이상 복제할 수 있다. 복제되면 각 색인은 기본 샤드(복제 원본 샤드)와 리플리카 샤드(기본 샤드의 복사본)를 갖는다. 샤드 및 리플리카의 수는 색인별로, 색인 생성 시점에 정의할 수 있다. 색인이 생성된 다음 언제라도 탄력적으로 리플리카의 수를 변경할 수 있으나, 샤드 수는 사후 변경이 불가능하다. 기본적으로 Elasticsearch의 각 색인은 기본 샤드5개, 리플리카 1개를 갖는다. 따라서 클러스터에 최소한 2개의 노드가 있다면 색인은 5개, 리플리카 샤드 5개(원본 리플리카 1개)를 가지므로 색인당 총 10개의 샤드가 존재한다. 각 Elasticsearch의 각 색인은 Lucene 색인이다. 단일 Lucene 색인이 포함할 수 있는 문서 수의 최대 한도가 있다. (약 2,147,483,519개)

## **Shard**

- 부하 분산을 위해 Application/DB Level에서 다수의 DB를 분산 저장하는 기법

- DB분야에서 성능, 확장성 및 I/O 대역폭을 대선하는데 사용하는  분산처리 기법

- shard의 구성요소

  | 구성 요소                      | 설명                                                         |
  | ------------------------------ | ------------------------------------------------------------ |
  | vertical partitioning          | 데이블 별로 서버를 분할하는 방식                             |
  | Range Based Partitioning       | 하나의 테이블이 거대해질 경우 서버를 분리하는 방식           |
  | Key or Hash Based Partitioning | 키와 같은 값을 해쉬함수에 넣어 나오는 값으로 서버를 지정하는 방식 |
  | Directory Based Partitioning   | 파티셔닝 매커니즘을 제공하는 추상화된 서비스 생성            |

- shard 수행 시 고려사항

  | 고려사항      | 설명                                            |
  | ------------- | ----------------------------------------------- |
  | 데이터 재분배 | 서비스 정지 없이 DB shema 및 서버 설계 필요     |
  | 샤딩 조인     | 역정규화를 어느정도 감수해야 함                 |
  | 샤딩 알고리즘 | 정수값 등으로 샤딩을 처리할 때 데이터 비율 고려 |




## **Cache**

- Cache란 나중에 요청할 결과를 미리 저장해둔 후 빠르게 서비스해 주는 것을 의미한다. 즉 , 미리 결과를 저장할고 나중에 요청이 오면 그 요청에 대해서 DB 또는 API를 참조하지 않고 Cache를 접근하여 요청을 처리하는 기법이다. 이러한 Cache가 나온 배경에는 파레토 법칙 있다. 파레토 법칙이란 80%의 결과는 20% 의 원인으로 발생한다는 뜻으로 Cache는 모든 결과를 캐싱할 필요가 없으며 서비스를 할 때 많이 사용되는 20%만 캐싱함으로써 전체적으로 효율을 높일 수 있다.
- 서비스를 처음 운영할 때는 Clinent → WEB Server → WAS → DB 정도로 작게 인프라를 구축하는데, 사용자가 늘어나면 DB에 무리가 가기 시작한다. DB는 데이터를 물리 디스크에 직접 쓰기 때문에 서버에 문제가 발생해도 데이터가 손실되지는 않디만, 매 transaction마다 디스크에 접근해야하므로 부하가 많아지면 성능이 떨어질 수 밖에 없다. 그래서 사용자 늘어나면 DB를 스케일 인 또는 스케일 아웃하는 방식 외에도 캐시 서버를 검토하게 된다.
- Clinent → Sever → Cache → DB 클라이언트가 웹 서버에 요청을 보내면, 웹 서버는 데이터를 DB에서 가져오기 전에 캐시 데이터가 있는지 확인하고, 있다면 바로 클라이언트에게 저장된 데이터를 반환한다. 이를 Cache Hit이라고 한다. 반대로 캐시 서버에 데이터가 없으면 DB에 데이터를 요청하여 원하는 데이터를 조회한 후 그 데이터를 클라이언트에게 제공하는데 , 이를 Cache Miss라고 한다. 캐시를 어떻게 사용하느냐에 따라서 look aside cache와 write back으로 나뉜다.
- **Look Aside Cache(Lazy loading)**
  - 캐시에 데이터 존재유무 확인
  - 데이터가 있다면 캐시의 데이터 사용
  - 데이터가 없다면 캐시의 실제 DB 데이터 사용
  - DB에서 가져 온 데이터를 캐시에 저장
  - look aside cache는 캐시를 한 번 접근하여 데이터가 있는지 판단한 후, 있다면 캐시 데이터를 사용하고 없으면 DB또는 API를 호출한다. 대부분의 캐시를 사용한 개발이 해당 프로세스를 따릅니다.
- **Write Back**
  - 모든 데이터를 캐시에 저아
  - 캐시의 데이터를 일정 주기마다 DB에 한꺼번에 저장(Batch)
  - DB에 저장한 데이터를 캐시에서 제거
  - write back은 주로 쓰기 작업이 굉장히 많아서, INSERT 쿼리를 일일이 날리지 않고 한꺼번에 처리를 하기 위해 사용한다. 예를 들어 영어 듣기 평가를 온라인으로 진행하는 서비스가 있을 때, 여러 학생이 동시에 제출 버튼을 누르면서 DB에 갑작스럽게 엄청난 쓰기 요청이 몰리게 되면 DB 서버가 죽을 수도 있다. 이때 write back 기반의 캐시를 사용하면 캐시 메모리에 데이터를 저장해 놓고, 이후 DB 디스크에 업데이트 해 주면 안전하게 쓰기 작업을 이행 할 수 있다. DB에서 디스크를 접하는 횟수가 줄어들기 때문에 성능 향상을 기대할 수 있지만 DB에 데이터를 저장하기 전에 캐시 서버가 죽으면 데이터가 유실된다는 문제점이 있다.

## **Memcached**

- memcached는 무료로 사용할 수 있는 오픈 소스이며 분산 메모리 캐싱 시스템이다. DB의 부하를 줄요 WAS의 속도 개선을 위해 사용하며, DB나 API 호출 또는 렌더링 등으로부터 받아오느 결과 데이틀 **Key-vlaue** 형태로 메모리에 저장한다.
- **장점**
  - 시스템의 사용되지 않는 일부 메모리를 활용할 수 있어 남는 자원을 효율적으로 사용하여 성능을 향상시킬 수 있다.
  - consistent hash 알고리즘을 사용하여 물리적인 별도의 캐시 서버를 로직 상 하나의 서버로 보고 사용할 수 있도록 했다.  즉, 개발자는 서버가 몇 대든 상관없이 한 개의 객체만을 활용하여 저장 및 조회할 수 있으므로 능률적이고 대용량의 캐시 시스템을 갖게 되는 것이다. 
- **단점**
  - 인 메모리 기반의 시스템이므로 재부팅 시 데이터가 소멸하고 이로 인해 영구적인 저장용 시스템을  활요할 수 없다는 문제가 있다. 만약 영구 저장이 필요하다면 해당 데이터를 DB에 저장해 두고, 재부팅 시 DB로 부터 데이터를 받아야 한다.

## **Redis**

- Redis는 오픈 소스로 NoSQL로 분류되기도 하고 Memcached와 같이 고성능 키-값 저장소를 가진 인 메모리 솔루션으로 분류되기도 한다. 성능은 Memcahed에 버금가면서 다양한 데이터 구조체를 지원함으로써 DB, Cache, Message Queue, Shared Memory용도로 사용될 수 있다. 또한 디스크에 데이터를 쓰는 구조가 아니라 메모리에서 데이터를 처리하기 때문에 작업 속도가 상당히 빠르다. 

- **Redis 특징**

  - 영속성을 지원하는 인 메모리 데이터 저장소
  - 다양한 자료 구조를 지원
  - 싱글 스레드 방식으로 인해 연산을 원자적으로 수행이 가능
  - 읽기 성능 증대를 위한 서버 측 리플리케이션 지원
  - 쓰기 성능 증대를 위한 클라이언트 측 샤딩 지원
  - 다양한 서비스에서 사용되며 검증된 기술

- **Redis의 영속성**

  - Redis는 영속성을 보장하기 위해 데이터를 디스크에 저장할 수 있다. 서버가 내려가더라고 디스크에 저당된 데이터를 읽어서 메모리에 로딩합니다. 데이터를 디스크에 저장하는 방식은 크게 두가지가 있다.

  - RDB(Snapshotting)방식

    순간적으로 메모리에 있는 내용 전체를 디스크에 옮겨 담는 방식

  - AOF(Append On File)방식

    Redis의 모든 write/update 연산 자체를 모두 log 파일에 기록하는 형태

- **Redis의 Thread Safe**

  - 싱글 스레드 방식이어서 연산을 하나씩 처리한다.

- **Redis의 속도**

  - **Key-Value** 방식이므로 쿼리를 날리지 않고 결과를 얻을 수 있다.

- **Redis와 Memchached 차이**

  |                     | Redis                                                        | Memcached                                |
  | ------------------- | ------------------------------------------------------------ | ---------------------------------------- |
  | 스레드              | 싱글 스레드                                                  | 멀티 스레드                              |
  | 데이터 구조         | list, string, hashes, sorted, bimaps등 다양한 자료 구조 지원 | string과 integers만 지원                 |
  | 데이터 저장         | Memory, Disk                                                 | Only Memory                              |
  | 처리 속도           | Memcached 보다는 느리지만 큰 차이는 없다.                    | 디스크를 거치지 않아 redis보다 더 빠르다 |
  | Replication         | 지원                                                         |                                          |
  | Partitioning method | 지원                                                         |                                          |
  | persistence         | 영속성있는 데이터 사용                                       |                                          |

- **Docker Redis CMD**

- redis: docker exec -it [redis_container name] sh → redis-cli
- redis 연결 확인: redis-server → redis-cli ping → pong
- SET 키 값 
- GET 키 값
- DEL 키
- SELECT DB번호
- netstat -anv|grep LISTEN: 현재 사용중인 네트워크 확인
- redis-cli -h docker container name -p docker container port

- npm -rf package-lock.json
- npm -rf node modules